<!doctype html>
  <head>
    <meta charset="utf-8">
    <title>Mathr Prototype</title>
    <meta name="description" content="Mathr Prototype">
    <meta name="viewport" content="width=device-width">
    <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

    <!-- build:css styles/vendor.css -->
    <!-- bower:css -->
    <!-- endbower -->
    <!-- endbuild -->

    <!-- build:css({.tmp,app}) styles/main.css -->
    <link rel="stylesheet" href="styles/main.css">
    <!-- endbuild -->

    <link rel="stylesheet" href="styles/fonts.css">

    <link rel="jsandbox" href="bower_components/jsandbox/src/jsandbox-worker.js" />

  </head>
  <body>
    <div class="container" id="page1"></div>

    <!-- build:js scripts/vendor.js -->
    <!-- bower:js -->
    <script src="bower_components/jquery/dist/jquery.js"></script>
    <script src="bower_components/bacon/dist/Bacon.js"></script>
    <script src="bower_components/numeral/numeral.js"></script>
    <script src="bower_components/filtrex/filtrex.js"></script>
    <script src="bower_components/fluxxor/build/fluxxor.min.js"></script>
    <script src="bower_components/uuid-js/lib/uuid.js"></script>
    <!-- endbower -->
    <script src="http://quilljs.com/js/quill.js"></script>
    <script src="bower_components/react/react.js"></script>
    <script src="bower_components/react/JSXTransformer.js"></script>
    <script src="bower_components/jsandbox/src/jsandbox.js"></script>
    <script src="bower_components/q/q.js"></script>
    <!-- endbuild -->

    <!-- build:js({.tmp,app}) scripts/scripts.js -->
    <!-- <script src="scripts/grammars/mathr.js"></script> -->
    <script src="scripts/compiler.js"></script>
    <script src="scripts/app.js"></script>
    <script src="scripts/mathr.js"></script>
    <!-- <script src="scripts/controllers/main.js"></script> -->
    <!-- endbuild -->

    <script type="text/jsx">
    /**
     * @jsx React.DOM
     */


    /**
     * Application Config
     */
    var __config = {
      lineHeight: 30,
      editors: [],
      quillSetup: {
        styles: {
          'body': {
            'font-family': 'Source Code Pro, ',
            'font-size': '18px',
            'white-space': 'pre',
            'line-height': '30px',
            'padding': 0,
            'height': 'auto',
            'overflow-y': 'hidden'
          },
          'html': {
            'height': 'auto'
          },
          'editor-container': {
            'height': 'auto'
          }
        },
        logLevel: 'debug',
        modules: {
          'multi-cursor': {}
        },
        formats: ['bold']
      }
    };


    /**
     * Flux Stores
     */
    var ErrorStore = Fluxxor.createStore({
      actions: {
        "ADD_ERROR": "onAddError",
        "CLEAR_ERRORS": "onClearErrors"
      },

      initialize: function() {
        this.errors = [];
      },

      onAddError: function(payload) {
        console.log(payload)
        this.errors.push({
          id: UUIDjs.create(4).toString(),
          message: payload.message,
          time: (new Date())
        });
        this.emit("change");
      },

      onClearErrors: function() {
        this.errors = [];
        this.emit("change");
      },

      getState: function() {
        return {
          errors: this.errors
        };
      }
    });

    // TODO: switch to using this doc store
    var DocStore = Fluxxor.createStore({
      actions: {
        "GET_DOC": "onGetDoc",
        "CLEAR_DOC": "onClearPages"
      },

      initialize: function() {
        this.doc = {};
      },

      onGetDoc: function (payload) {
        $.ajax({
          url: payload.url,
          dataType: 'json',
          success: function(doc) {
            this.doc = doc;
            // PageStore.onAddPages({pages: doc.pages});
            this.emit("change");
          }.bind(this),
          error: function(xhr, status, err) {
            console.error(payload.url, status, err.toString());
          }.bind(this)
        });
      },

      getState: function() {
        return {
          doc: this.doc
        };
      }
    });

    var PageStore = Fluxxor.createStore({
      actions: {
        "ADD_PAGE": "onAddPage",
        "ADD_PAGES": "onAddPages",
        "TOGGLE_PAGE": "onTogglePage",
        "UPDATE_PAGE": "onUpdatePage",
        "CLEAR_PAGES": "onClearPages",
        "GET_PAGES": "onGetPages"
      },

      initialize: function() {
        this.pages = [];
      },

      onAddPage: function(payload) {
        // console.log(payload)
        this.pages.push({
          id: payload.page.id || UUIDjs.create(4).toString(),
          type: payload.page.type,
          name: payload.page.name,
          input: payload.page.input,
          output: null,
          hidden: false
        });
        this.emit("change");
      },

      onAddPages: function(payload) {
        for (var i = 0, l = payload.pages.length; i < l; i++) {
          var page = payload.pages[i];
          this.pages.push({
            id: page.id || UUIDjs.create(4).toString(),
            type: page.type,
            name: page.name,
            input: page.input,
            output: null,
            hidden: false
          });
        }
        this.emit("change");
      },

      onTogglePage: function(payload) {
        payload.page.hidden = !payload.page.hidden;
        this.emit("change");
      },

      onUpdatePage: function(payload) {
        // console.log(payload)
        this.emit("change");
      },

      onClearPages: function() {
        this.pages = this.pages.filter(function(page) {
          return page.hidden;
        });
        this.emit("change");
      },

      onGetPages: function(payload) {
        // TODO: replace me with a better store
        $.ajax({
          url: payload.url,
          dataType: 'json',
          success: function(doc) {
            // this.setState({pages: pages});
            this.onAddPages({pages: doc.pages});
          }.bind(this),
          error: function(xhr, status, err) {
            console.error(payload.url, status, err.toString());
          }.bind(this)
        });
      },

      getState: function() {
        return {
          pages: this.pages
        };
      }
    });


    /**
     * Flux Actions
     */
    var actions = {
      addPage: function(page) {
        this.dispatch("ADD_PAGE", {page: page});
      },
      addPages: function(pages) {
        this.dispatch("ADD_PAGES", {pages: pages});
      },
      togglePage: function(page) {
        this.dispatch("TOGGLE_PAGE", {page: page});
      },
      updatePage: function(page) {
        this.dispatch("UPDATE_PAGE", {page: page});
      },
      clearPages: function() {
        this.dispatch("CLEAR_PAGES");
      },
      getPages: function(url) {
        this.dispatch("GET_PAGES", {url: url});
      },
      addError: function(message) {
        this.dispatch("ADD_ERROR", {message: message});
      },
      getDoc: function(url) {
        this.dispatch("GET_DOC", {url: url});
      }
    };

    var stores = {
      DocStore: new DocStore(),
      PageStore: new PageStore(),
      ErrorStore: new ErrorStore()
    };



    /**
     * Flux Init
     */
    var flux = new Fluxxor.Flux(stores, actions);
    var FluxMixin = Fluxxor.FluxMixin(React),
        FluxChildMixin = Fluxxor.FluxChildMixin(React),
        StoreWatchMixin = Fluxxor.StoreWatchMixin;



    /**
     * Sheet Views
     */
    var SheetColumn = React.createClass({
      render: function () {
        return (
          <td data-col={this.props.col}>{this.props.val}</td>
        );
      }
    });
    var SheetRow = React.createClass({
      render: function () {
        return (
          <tr data-row="{this.props.row}">
            <SheetColumn col="a" val={this.props.a} />
            <SheetColumn col="b" val={this.props.b} />
          </tr>
        );
      }
    });
    var Sheet = React.createClass({
      // TODO: use this? http://handsontable.com/
      render: function () {
        return (
          <table data-table="1" className="table">
            <thead>
              <th>Sheet Name</th>
            </thead>
            <SheetRow row="1" a="coffee" b="$4.00" />
            <SheetRow row="2" a="milk" b="$3.75" />
            <SheetRow row="3" a="water" b="$6.25" />
          </table>
        );
      }
    });


    /**
     * Error Views
     */
    var ErrorItem = React.createClass({
      render: function () {
        return (
          <p>{'#' + this.props.key +
            ' (' +
              this.props.error.time.getUTCMinutes() + ':' +
              this.props.error.time.getUTCSeconds() + '.' +
              this.props.error.time.getUTCMilliseconds() +
              ')' + ': ' +
            this.props.error.message}</p>
        );
      }
    });
    var ErrorList = React.createClass({
      mixins: [FluxChildMixin],

      render: function () {
        var errorLines = this.props.errors.map(function (error, index) {
          return <ErrorItem error={error} key={index+1} />
        }.bind(this));
        // console.log('errors', this.props.errors)
        return (
          <div className="row m-error m-error--container col-md-12">
            <h3 className="row m-error--hed">Error Log</h3>
            <div className="row m-error--row">
              {this.props.errors ? errorLines.reverse() : <p>No errors (yet).</p>}
            </div>
          </div>
        );
      }
    });


    /**
     * Gutter Views
     */
    var GutterLine = React.createClass({
      render: function () {
        return (
          <a data-line={this.props.line} name={"l_"+this.props.key} href={"#l_"+this.props.key} key={this.props.key}>{this.props.line}</a>
        );
      }
    });
    var Gutter = React.createClass({
      countLines: function (rows) {
        var gNums = [];
        for (var i = 1; i <= rows; i++) {
          gNums.push(i);
        }
        this.setState({lines: gNums});
      },
      componentWillMount: function() {
        this.countLines(this.props.rows);
      },
      componentWillReceiveProps: function (nextProps) {
        this.countLines(nextProps.rows);
      },
      render: function () {
        var gutterLines = this.state.lines.map(function (line) {
          return <GutterLine line={line} key={this.props.key+'_'+line} />;
        }.bind(this));
        return (
          <div className="gutter col-md-1 col-xs-1 m-note--gutter">
            {gutterLines}
          </div>
        );
      }
    });


    /**
     * RTE Views
     */
    var EditorInput = React.createClass({
      input: null,

      resizeContainer: function () {
        if (this.rte && this.rte.editor.renderer) {
          var $container = this.rte.editor.renderer.container;
          $container.style.height = this.rte.root.clientHeight + 'px';
        }
      },
      editorUpdated: function (d, t, e) { // d, t, e
        // console.log([d, t, e]);
        this.input = this.rte.getText();
        // console.log(this.input)
        if (this.input !== this.props.input) {
          this.props.onInputUpdate(this.input);
        }
        this.resizeContainer();
      },
      installRTE: function () {
        this.rte = new Quill(this.getDOMNode(), __config.quillSetup);

        if (this.props.input) {


          // TODO Switch the input to lines/array instead?


          // this.rte.setContents([
          //   { value: this.props.input },
          //   { value: '' }
          // ]);
          this.rte.setHTML(this.props.input);
          // this.rte.insertText(0, this.props.input);
        }
        this.resizeContainer();

        setTimeout(function () {
          // it needs time to init
          // TODO: use a callback below instead
          this.resizeContainer();
          // this.props.onInputUpdate(this.props.input);
        }.bind(this), 1);

        this.rte
          .on('renderer-update', this.editorUpdated)
          .on('text-change', this.editorUpdated)
          .on('pre-event', function () { // d, t, e
            // console.log('pe', d, t, e);
          }.bind(this));
      },
      componentDidMount: function () {
        // console.log(this.props.input);
        if (!this.rte) {
          this.installRTE();
          this.resizeContainer();
        }
      },
      componentWillReceiveProps: function (nextProps) {
        if (!this.rte) {
          this.installRTE();
        }
        if (nextProps.input !== this.input) {
          // this.rte.setContents({ text: nextProps.input });
          // TODO: do this only sparingly under certain conditions
          // this might have been updated from the editor itself.
          this.rte.setHTML(nextProps.input);
          // this.rte.insertText(0, nextProps.input);
          this.resizeContainer();
        }
      },
      render: function () {
        return (
          <div className="editor col-md-6 col-xs-6 m-note--input"></div>
        );
      }
    });
    var EditorOutputLine = React.createClass({
      render: function () {
        // console.log(this.props)
        // this is an array. some of the values are arrays. we can use them more wisely.
        return (
          <span dangerouslySetInnerHTML={{__html: this.props.text}}></span>
        );
      }
    });
    var EditorOutput = React.createClass({
      render: function () {
        var lineList = this.props.output ? this.props.output.map(function (text, i) {
          return <EditorOutputLine text={text} key={i}/>;
        }) : [];
        return (
          <div className="col-md-5 col-xs-5 m-note--output">{lineList}</div>
        );
      }
    });


    /**
     * Notes View
     */
    var Note = React.createClass({
      mixins: [FluxChildMixin],

      flattenTables: function () {
        var flux = this.getFlux();
        // console.log(flux)
        // Normally we'd use one key per store, but we only have one store, so
        // we'll use the state of the store as our entire state here.
        var tables = (flux.store("PageStore").getState().pages).filter(function (i) {
          return i.type === 'table';
        }).map(function (i) {
          return i.input;
        });

        return tables;
      },

      flattenFuncs: function () {
        var flux = this.getFlux();
        // console.log(flux)
        // Normally we'd use one key per store, but we only have one store, so
        // we'll use the state of the store as our entire state here.
        var tables = (flux.store("PageStore").getState().pages).filter(function (i) {
          return i.type === 'function';
        });

        return tables;
      },

      funcItemToFunction: function (item) {
        // var q = Q.defer();
        // console.log(item)
        // TODO: convert this into an actual, usable function:
        // "function multiplyList (v, m) {\n\tfor(var i in v) {\n\t\ti = i * m;\n\t};\n\treturn v;\n};"
        // then add this to the list of functions available to the compiler below

        // first thoughts:
        // ? namespace the function, ex.: functions.multiplyList
        // parse out "function XXX(XXX){XXX}"
        // read up on eval for JS
        // use the compiler?
        var func = eval(item.input);
        var name = eval(item.name);
        // console.log(this)
        // console.log(this[item.name])
        // console.log(name)
        // TODO: switch to jsandbox here
        // jsandbox.eval({
        //   code: item.input,
        //   input: figure this out
        //   callback: function (x) {
        //     q.resolve(x);
        //   },
        //   onerror: function (e) {
        //     throw new Error(e);
        //   }
        // });
        // return q.promise;
        return name;
      },

      tableLookup: function (tables) {
        return function (symbol) {
          // console.log('table:', symbol, this, tables)
          var t = symbol.split('')[1] - 1;
          return tables[t]; // returns an array
        }
      },

      tablecellLookup: function (tables) {
        return function (symbol) {
          // console.log('tablecell:', symbol, this, tables)
          var cToI = 'abcdefghijklmnopqrstuvwxyz'.split(''),
            s = symbol.split(''),
            table = s[1] - 1,
            row = cToI.indexOf(s[3]); // char to int

          if(s[4]) {
            // get a cell
            col = s[4] - 1;
            // console.log([symbol, table, row, col, tables[table][row][col]]);
            return tables[table][row][col]; // returns a value
          } else {
            // get a row
            // console.log([symbol, table, row, tables[table][row]]);
            return tables[table][row]; // returns an array
          }
        }
      },

      solveLines: function (rawCode) {
        // console.log(rawCode);
        function stripTags (string) {
          if (!string) {
            return '';
          }
          string = string.replace(/<\/p>/ig, '\n');
          string = string.replace(/(<([^>]+)>)/ig, '');
          return string;
        }

        var compiled = [],
          rendered = {},
          rerendered = [],
          code = rawCode;
        code = stripTags(code);
        var lines = code.split('\n');

        var tables = this.flattenTables();
        var funcs = this.flattenFuncs();

        rendered['t1.b1'] = 3; // just a test
        var extraFunctions = {};
        extraFunctions.table = this.tableLookup(tables);
        extraFunctions.tablecell = this.tablecellLookup(tables);
        // TODO add function pages

        funcs.forEach(function (func, i) {
          extraFunctions[func.name] = this.funcItemToFunction(func);
        }.bind(this));

        console.log('extraFunctions', extraFunctions);

        // first rendering pass
        lines.forEach(function (line, i) {
          try {
            compiled[i] = compileExpression(line, extraFunctions);
            rendered['l' + (i + 1)] = compiled[i](rendered);
          } catch (e) {
            console.error(e);
            this.getFlux().actions.addError(e.toString());
          }
        }.bind(this));
        // console.log(compiled);
        // console.log(rendered);

        compiled.forEach(function (line, i) {
          try {
            rendered['l' + (i + 1)] = rerendered[i] = this.normalizeString(line(rendered));
            // rendered['l' + (i + 1)] = rerendered[i];
          } catch (e) {
            console.error(e);
            this.getFlux().actions.addError(e.toString());
          }
        }.bind(this));
        // console.log(rerendered);

        return rerendered;
      },

      normalizeString: function (string) {
        // just remove the currency output for now
        if (typeof string === 'string' && string.substr(0, 1) === '$') {
          return string.substr(1, string.length);
        } else {
          return string;
        }
      },

      handleInputUpdate: function (update) {
        // console.log('update:', update);
        // this.setState({
        //   input: update.input
        // });
        // this.setState({
        //   input: update.input,
        //   output: update.output
        // });
        // console.log(this.props.item.input, update)
        if (update && this.props.item.input !== update) {
          this.props.item.input = update;
        }
        this.props.item.output = this.solveLines(update);

        // this.setState();
        // console.log(update, this.props.item)
        if (!this.init) {
          // skip this on the first run
          this.getFlux().actions.updatePage(this.props.item);
        } else {
          this.init = false;
        }
      },
      componentDidMount: function () {
        this.init = true;
        this.props.item.output = this.solveLines(this.props.item.input);

        // FIXME: enable this but don't update this.props.item.input since that's what triggered this! that change rerenders the RTE and we lose our cursor.
        this.getFlux().actions.updatePage(this.props.item);
      },
      getInitialState: function() {
        return {};
      },
      render: function () {
        // console.log(this.props)
        // console.log(this.props.item.input.split('\n'))
        return (
          <div className="row m-note m-note--container col-md-12">
            <h3 className="row m-note--hed">{this.props.item ? this.props.item.name : ''}</h3>
            <div className="row m-note--row">
              <Gutter key={this.props.item.id} rows={this.props.item.input ? this.props.item.input.split('\n').length : 10} />
              <EditorInput input={this.props.item.input ? this.props.item.input : ''} onInputUpdate={this.handleInputUpdate} />
              <EditorOutput output={this.props.item.output ? this.props.item.output : ''} />
            </div>
          </div>
        );
      }
    });


    /**
     * Func View
     */
    var Func = React.createClass({
      mixins: [FluxChildMixin],

      handleInputUpdate: function (input) {
        // console.log('input update:', input);
        // this.getFlux().actions.updatePage(this.props.item);
      },
      render: function () {
        // console.log(this.props.item.input.split('\n').length)
        return (
          <div className="row m-func m-note--container col-md-12">
            <h3 className="row m-note--hed">{this.props.item ? this.props.item.name : ''}</h3>
            <div className="row m-note--row">
              <Gutter key={this.props.item.id} rows={this.props.item.input ? this.props.item.input.split('\n').length : 10} />
              <EditorInput input={this.props.item.input ? this.props.item.input : ''} onInputUpdate={this.handleInputUpdate} />
            </div>
          </div>
        );
      }
    });



    /**
     * Application View
     */
    var Application = React.createClass({
      mixins: [FluxMixin, StoreWatchMixin("DocStore", "PageStore", "ErrorStore")],

      getStateFromFlux: function() {
        var flux = this.getFlux();
        console.log(flux.store("PageStore"))
        console.log(flux.store("ErrorStore"))
        // Normally we'd use one key per store, but we only have one store, so
        // we'll use the state of the store as our entire state here.
        return {
          doc: flux.store("DocStore").getState(),
          pages: flux.store("PageStore").getState(),
          errors: flux.store("ErrorStore").getState(),
        }
      },

      componentWillMount: function() {
        // console.log(this);
        // this.getFlux().actions.getDoc(this.props.url);
        this.getFlux().actions.getPages(this.props.url);
      },
      getInitialState: function() {
        return {};
      },
      render: function () {
        //<Func item={this.state.pages[2]} />
        // console.log(this.state)
        var pageList = this.state.pages.pages.map(function (item) {
          switch (item.type) {
            case 'note':
              return <Note item={item} key={item.id} />;
            case 'function':
              return <Func item={item} key={item.id} />;
            case 'table':
              return <Sheet item={item} key={item.id} />;
            default:
              return null;
          }
        });
        return (
          <div className="container">
            {pageList}
            <ErrorList errors={this.state.errors ? this.state.errors.errors : null} />
          </div>
        );
      }
    });

    React.renderComponent(
      <Application url="/scripts/fixtures/doc1.json" flux={flux} />,
      document.getElementById('page1')
    );
    </script>
</body>
</html>